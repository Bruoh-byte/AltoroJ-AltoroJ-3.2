package com.ibm.security.appscan.altoromutual.servlet;
//Author: Group 5

//Utilizes Apache Commons, please make sure you refresh your gradle project to utilize the imports or this will NOT work.
import java.io.*;
import java.util.zip.*;
import java.util.List;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

/*The following Servlet handles FileUploads for the intention of uploading checks however has multiple vulnerabilities
 * Frontend logic calling this is located within transfer.jsp and mapped accordingly within web.xml
 * The vulnerabilities are: No Checking for file types, and allowing the maximum possible upload size, as well as path traversal through the unzip method
 * Solution: Specify JPEGS and PNG uploads, as well as cap the size to something reasonable, such as 5 MB or (1024 * 1024 * 5) bytes, then in the unzip method >
 * Sanitize the file names for ../ and ensure their canonical path is the upload directory we desire or deny it, this is an efficient mitigation method for preventing path traversal
 */
public class FileUploadServlet extends HttpServlet {
	private static final long serialVersionUID = 1L; //These were in all the servlets, dont know why.
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
        if (ServletFileUpload.isMultipartContent(request)) { //Is the request hitting this backend logic an upload? In the case someone hits upload without a file.
            DiskFileItemFactory factory = new DiskFileItemFactory(); //Make a DiskFileItemFactory to handle File Requests
            
            factory.setSizeThreshold(Integer.MAX_VALUE); // Some big ole numba
            ServletFileUpload upload = new ServletFileUpload(factory); //ServletFileUpload Object handles the transportation of file requests, utilizing factory.
            upload.setFileSizeMax(Long.MAX_VALUE); // Some big ole numba
            upload.setSizeMax(Long.MAX_VALUE); // Some big ole Numba
            //Find a way to make Upload Path to be able to be used globally
            String finalPath = getServletContext().getRealPath("/checks");
            
            String uploadPath = finalPath; // Set Upload Path here
            File uploadDir = new File(uploadPath); //This sets the directory of where files will go.
            if (!uploadDir.exists()) {
                uploadDir.mkdirs(); // This will create a folder following the above path if it doesnt exist within the app if configured carefully and correctly.
            }
            try {
                List<FileItem> formItems = upload.parseRequest(request); // Make a new list to parse upload/uploads (In case someone uploads a folder) / Multipart requests break down complex files
                for (FileItem item : formItems) { //For each FileItem within the list
                    if (!item.isFormField()) { //If the item is a file, which it should be, do logic
                        String fileName = new File(item.getName()).getName(); //Get the files Name, we need this for file checking
                        File storeFile = new File(uploadPath, fileName); //Get the file and its path
                        item.write(storeFile); // Save the file to directory / Yes even the ZIP for case check
                        
                        if (fileName.endsWith(".zip")) { // Send it away for Path Traversal Vulnerability!!! :D
                        	unzip(storeFile, uploadPath);
                        }
                        
                        
                        response.getWriter().print("File uploaded successfully to " + storeFile.getAbsolutePath()); //Tell the user the result, takes them to a new page, couldnt figure out the frontend stuff
                        return; // Once uploaded, exit via return
                    }
                }
            } 
            catch (Exception e) {
                response.getWriter().print("File upload failed.");
            }
        } 
        else { //If user put nothing in upload and processed, tell them.
            response.getWriter().print("Invalid request.");
        }
    }
    public static void unzip(File zipFile, String uploadPath) throws IOException {
        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile))) { //Take the zipfile into ZipInputStream Javas built in Zip Handling. compressed and uncompressed entries
            ZipEntry entry; // Javas built in Zip Entry Object
            byte[] buffer = new byte[1024]; // This buffer array handles all the bytes that come through when reading files, cause again, files are transfered via 1s and 0s, make this bigger if you have good performance
            while ((entry = zis.getNextEntry()) != null) { // Retrieve the next available file or directory in the zip file
                File newFile = new File(uploadPath + File.separator + entry.getName()); //Upload path + / + file name using the 2nd File Constructor utilizing just a string
                if (entry.isDirectory()) { // Is it a folder?
                    newFile.mkdirs(); // Make it
                } else {
                    new File(newFile.getParent()).mkdirs(); //Make sure its parent exists, or else you have an orphan file who may not go where they belong
                    try (FileOutputStream fos = new FileOutputStream(newFile)) { // Make file in the desired directory, PATH TRAVERSAL VULNERABILITY
                        int length;
                        while ((length = zis.read(buffer)) > 0) { //Read the compressed files size and while its not zero, start writing it together
                            fos.write(buffer, 0, length); //Write the file in the respective binary, when its all done, the 1s and 0s in the right arrangement make your file :)
                        }
                    }
                }
            }
        }
    }
}
